
import java.util.ArrayList;
import java.util.Stack;

public class RecursiveDescent {

	private Stack<NFA> stack;
	//already defined identifiers
	private ArrayList<NFA_Identifier> defined;
	//stream to parse
	private Lexer lexer;
	//flag to scope back in
	private boolean scope_back;
	///flag to differentiate char classes
	private boolean char_class;

	/**
	 * setup parser with given input stream and defined identifiers
	 * @param lexer input stream to use
	 * @param defined list of defined identifiers (char classes and regular expressions)
	 */
	public RecursiveDescent(Lexer lexer, ArrayList<NFA_Identifier> defined) {
		this.lexer = lexer;
		this.defined = defined;
		this.stack = new Stack<NFA>();
		this.scope_back = false;
		this.char_class = true;
	}
	
	/**
	 * initialize the recursive descent
	 * @return nfa generated by recursive descent
	 */
	public NFA_Identifier descend() {
		stack.push(new NFA());
		regEx();
		NFA new_nfa = stack.pop();
		new_nfa.finalize();
		NFA_Identifier result;
		if(char_class) {
			result = new NFA_Identifier(null, new_nfa, true);
		}
		else {
			result = new NFA_Identifier(null, new_nfa, false);
		}
		return result;
	}
	
	/**
	 * <regEx> ->  <rexp> 
	 */
	private void regEx(){
		rexp();
	}
	
	/**
	 * <rexp> -> <rexp1> <rexp$>
	 */
	private void rexp(){
		rexp1();
		rexp$();
	}
	
	/**
	 * <rexp1> -> <rexp2> <rexp1$>
	 */
	private void rexp1(){
		rexp2();
		rexp1$();
	}
	
	/**
	 * <rexp$> -> UNION <rexp1> <rexp$>  |  E 
	 */
	private void rexp$(){
		TokenType type = lexer.peekNextToken().getType();
		if (type == TokenType.UNION){
			char_class = false;
			lexer.getNextToken();//consume UNION
			
			NFA t2 = stack.pop();
			
			/* current --(EPSILON)--> end
			 * current = start
			 * current --(EPSILON)--> new
			 * current = new
			 */
			t2.addTransition(t2.getCurr(), t2.getEnd(), NFA.EPSILON);
			NFA.State s1 = t2.addTransition(t2.getStart(), t2.addState(), NFA.EPSILON);
			s1.setPrev(t2.getStart());
			t2.addTransition(t2.getStart(), s1, NFA.EPSILON);
			t2.setCurr(s1);
			
			rexp1();
			rexp$();
		}
		else
			return;
	}
	
	/**
	 * <rexp1$> -> <rexp2> <rexp1$>  |  E 
	 */
	private void rexp1$(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LPAREN || type == TokenType.DOT || type == TokenType.LBRACKET || type == TokenType.DEFINED) {
			rexp2();
			rexp1$();
		}
		else if(type == TokenType.LITERAL) {
			//make sure it's an RE_CHAR
			boolean valid = check_valid(lexer.peekNextToken(), RE_CHAR);
			if(!valid) {
				return;
			}
			
			rexp2();
			rexp1$();
		}
		else
			return;
	}
	
	/**
	 * <rexp2> -> (<rexp>) <rexp2Tail>  | RE_CHAR <rexp2Tail> | <rexp3>
	 */
	private void rexp2(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LPAREN){
			char_class = false;
			stack.push(new NFA());
			lexer.getNextToken();//consume LPAREN
			rexp();
			lexer.getNextToken();//consume RPAREN
			scope_back = true;
			rexp2Tail();
		}
		else if(type == TokenType.LITERAL){
			//make sure it's valid
			boolean valid = check_valid(lexer.peekNextToken(), RE_CHAR);
			if(!valid) {
				return;
			}
			//TODO add nfa transitions
			
			
			lexer.getNextToken();//consume LITERAL
			rexp2Tail();
		}
		else{
			rexp3();
		}
	}
	
	/**
	 * <rexp2Tail> -> * | + |  E
	 */
	private void rexp2Tail() {
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.KLEENE){
			char_class = false;
			lexer.getNextToken();
			if(scope_back) {
				scope_back = false;
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> start
				 * start --(EPSILON)--> new
				 * current = new
				 */
				t2.addTransition(t2.getCurr(), t2.getStart(), NFA.EPSILON);
				NFA.State s1 = t2.addTransition(t2.getStart(), t2.addState(), NFA.EPSILON);
				t2.setCurr(s1);
				//scope in
				NFA t1 = stack.pop();
				t1.concat(t2);
				stack.push(t1);
			}
			else {
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> current.previous
				 * current.previous --(EPSILON)--> new
				 * current = new
				 */
				NFA.State s1 = t2.addTransition(t2.getCurr(), t2.getCurr().getPrev(), NFA.EPSILON);
				t2.setCurr(s1);
				s1 = t2.addTransition(t2.getCurr(), t2.addState(), NFA.EPSILON);
				s1.setPrev(t2.getCurr());
				t2.setCurr(s1);
				//put back onto stack
				stack.push(t2);
			}
		}
		else if(type == TokenType.PLUS){
			char_class = false;
			lexer.getNextToken();
			if(scope_back) {
				scope_back = false;
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> start
				 * current = current
				 */
				t2.addTransition(t2.getCurr(), t2.getStart(), NFA.EPSILON);
				//scope in
				NFA t1 = stack.pop();
				t1.concat(t2);
				stack.push(t1);
			}
			else {
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> current.previous
				 * current = current
				 */
				t2.addTransition(t2.getCurr(), t2.getCurr(), NFA.EPSILON);
				
				//put back onto stack
				stack.push(t2);
			}
		}
		else {
			scope_back = false;
			
			//scope back in
			NFA t2 = stack.pop();
			NFA t1 = stack.pop();
			t1.concat(t2);
			stack.push(t1);
			
			return;
		}
	}
	
	/**
	 * <rexp3> -> <charClass>  |  E 
	 */
	private void rexp3(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.DOT || type == TokenType.LBRACKET || type == TokenType.DEFINED){
			charClass();
		}
		else
			return;
	}
	
	/**
	 * <charClass> ->  .  |  [ <charClass1>  | <definedClass>
	 */
	private void charClass(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.DOT){
			lexer.getNextToken();//consume DOT
			for(int i = 0; i < DOT_CHAR.length; i++) { 
				
				//TODO add nfa transitions
				
			}
		}
		else if(type == TokenType.LBRACKET){
			lexer.getNextToken();//consume LBRACKET
			charClass1();
		}
		else  {
			Token defined = lexer.getNextToken();
			definedClass(defined);
		}
	}
	
	/**
	 * <charClass1> ->  <charSetList> | <excludeSet>
	 */
	private void charClass1(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.CARET){
			excludeSet();
		}
		else{
			charSetList();
		}
	}
	
	/**
	 * <charSetList> ->  <charSet> <charSetList> |  E 
	 */
	private void charSetList(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LITERAL){
			//make sure the literal is a CLS_CHAR
			boolean valid = check_valid(lexer.peekNextToken(), CLS_CHAR);
			if(!valid) {
				return;
			}
			charSet();
			charSetList();
		}
		else
			return;
	}
	
	/**
	 * <charSet> -> CLS_CHAR <charSetTail> 
	 */
	private void charSet(){
		Token start = lexer.getNextToken();//consume LITERAL
		
		//TODO pass literal to nfa
		
		
		charSetTail(start);
	}
	
	/**
	 * <charSetTail> -> - CLS_CHAR | E
	 * @param start starting character for the range
	 */
	private void charSetTail(Token start){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.DASH){
			lexer.getNextToken();//consume DASH
			Token end = lexer.getNextToken();
			//make sure end is a CLS_CHAR
			boolean valid = check_valid(end, CLS_CHAR);
			if(!valid) {
				return;
			}
			//make set from range
			int start_index = ((int)start.getValue().charAt(0)) - 32;
			int end_index = ((int)end.getValue().charAt(0)) - 32;
			int current_index = start_index;
			while(current_index <= end_index) {
				
				//TODO add nfa transitions
				
				
				current_index++;
			}
		}
		else
			return;
	}
	
	/**
	 * <excludeSet> -> ^ <charSet>] IN <excludeSetTail>
	 */
	private void excludeSet(){
		lexer.getNextToken();//consume CARET
		charSet();
		lexer.getNextToken();//consume RBRACKET
		lexer.getNextToken();//consume IN
		excludeSetTail();
	}
	
	/**
	 * <excludeSetTail> -> [<charSet>]  | <definedClass>
	 */
	private void excludeSetTail(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LBRACKET){
			lexer.getNextToken();//consume LBRACKET
			charSet();
			lexer.getNextToken();//consume RBRACKET
		}
		else{
			Token token = lexer.getNextToken();
			definedClass(token);
		}
	}
	
	/**
	 * 
	 */
	private void definedClass(Token token){
		NFA_Identifier phony = new NFA_Identifier(token.getValue(), null, false);
		int index = this.defined.indexOf(phony);
		//make sure it exists
		if(index == -1) {
			//TODO error handling
		}
		NFA_Identifier defined_nfa = this.defined.get(index);
		NFA top = stack.pop();
		top.concat(defined_nfa.getNFA());
		stack.push(top);
	}
	
	/**
	 * check if the given token is contained in the given set
	 * @param token symbol to check validity of
	 * @param set set to check validity with
	 * @return true: token if valid, false: token is invalid
	 */
	private boolean check_valid(Token token, String[] set) {
		for(int i = 0; i < set.length; i++) {
			if(set[i].equals(token.getValue())) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * RE_CHAR set
	 */
	private static final String[] RE_CHAR = {
			"\\ ", "!", "\"", "#", "$", "%", "&", "\'", "\\(", "\\)", "\\*", "\\+", ",", "-", "\\.", "/",
			"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "\\?", 
			"@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", 
			"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "\\[", "\\", "\\]", "^", "_", 
			"`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", 
			"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "\\|", "}", "~"		
	};
	
	/**
	 * CLS_CHAR set
	 */
	private static final String[] CLS_CHAR = {
			" ", "!", "\"", "#", "$", "%", "&", "\'", "(", ")", "*", "+", ",", "\\-", ".", "/",
			"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", 
			"@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", 
			"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "\\[", "\\", "\\]", "\\^", "_", 
			"`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", 
			"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~"		
	};
	
	/**
	 * DOT_CHAR set
	 */
	public static final char[] DOT_CHAR = {
			'\\', '*', '+', '?', '|', '[', ']', '(', ')', '.', '\'', '\"'
	};
}

