
import java.util.ArrayList;
import java.util.Stack;

public class RecursiveDescent {

	private Stack<NFA> stack;
	//already defined identifiers
	private ArrayList<NFA_Identifier> defined;
	//stream to parse
	private Lexer lexer;
	//flag to scope back in
	private boolean scope_back;
	///flag to differentiate char classes
	private boolean char_class;

	/**
	 * setup parser with given input stream and defined identifiers
	 * @param lexer input stream to use
	 * @param defined list of defined identifiers (char classes and regular expressions)
	 */
	public RecursiveDescent(Lexer lexer, ArrayList<NFA_Identifier> defined) {
		this.lexer = lexer;
		this.defined = defined;
		this.stack = new Stack<NFA>();
		this.scope_back = false;
		this.char_class = true;
	}
	
	/**
	 * initialize the recursive descent
	 * @return nfa generated by recursive descent
	 */
	public NFA_Identifier descend() {
		stack.push(new NFA());
		regEx();
		NFA new_nfa = stack.pop();
		new_nfa.finalizeNFA();
		NFA_Identifier result = new NFA_Identifier(null, new_nfa, char_class);
		return result;
	}
	
	/**
	 * <regEx> ->  <rexp> 
	 */
	private void regEx(){
		rexp();
	}
	
	/**
	 * <rexp> -> <rexp1> <rexp$>
	 */
	private void rexp(){
		rexp1();
		rexp$();
	}
	
	/**
	 * <rexp1> -> <rexp2> <rexp1$>
	 */
	private void rexp1(){
		rexp2();
		rexp1$();
	}
	
	/**
	 * <rexp$> -> UNION <rexp1> <rexp$>  |  E 
	 */
	private void rexp$(){
		TokenType type = lexer.peekNextToken().getType();
		if (type == TokenType.UNION){
			System.out.println("  [CharClass] UNION found... not in char class");
			char_class = false;
			lexer.getNextToken();//consume UNION
			
			NFA t2 = stack.pop();
			
			/* current --(EPSILON)--> end
			 * current = start
			 * current --(EPSILON)--> new
			 * current = new
			 */
			t2.addTransition(t2.getCurr(), t2.getEnd(), NFA.EPSILON);
			NFA.State s1 = t2.addTransition(t2.getStart(), t2.addState(), NFA.EPSILON);
			s1.setPrev(t2.getStart());
			t2.setCurr(s1);
			
			stack.push(t2);
			
			rexp1();
			rexp$();
		}
		else
			return;
	}
	
	/**
	 * <rexp1$> -> <rexp2> <rexp1$>  |  E 
	 */
	private void rexp1$(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LPAREN || type == TokenType.DOT || type == TokenType.LBRACKET || type == TokenType.DEFINED) {
			rexp2();
			rexp1$();
		}
		else if(type == TokenType.LITERAL) {
			//make sure it's an RE_CHAR
			boolean valid = check_valid(lexer.peekNextToken(), RE_CHAR);
			if(!valid) {
				return;
			}
			
			rexp2();
			rexp1$();
		}
		else
			return;
	}
	
	/**
	 * <rexp2> -> (<rexp>) <rexp2Tail>  | RE_CHAR <rexp2Tail> | <rexp3>
	 */
	private void rexp2(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LPAREN){
			System.out.println("  [CharClass] LPAREN found... not in char class");
			char_class = false;
			stack.push(new NFA());
			lexer.getNextToken();//consume LPAREN
			rexp();
			lexer.getNextToken();//consume RPAREN
			scope_back = true;
			rexp2Tail();
		}
		else if(type == TokenType.LITERAL){
			System.out.println("  [CharClass] LITERAL found... not in char class");
			char_class = false;
			
			//make sure it's valid
			boolean valid = check_valid(lexer.peekNextToken(), RE_CHAR);
			if(!valid) {
				//TODO error handling
				return;
			}
			
			/* current --(Token.value)--> new
			 * current = new
			 */
			Token token = lexer.getNextToken();//consume LITERAL
			NFA t2 = stack.pop();
			
			char trans_val = token.getValue().charAt(0);
			if(trans_val == '\\') {
				trans_val = token.getValue().charAt(1);
			}
			
			NFA.State s1 = t2.addTransition(t2.getCurr(), t2.addState(), trans_val);
			s1.setPrev(t2.getCurr());
			t2.setCurr(s1);
			//push onto stack
			stack.push(t2);
			
			rexp2Tail();
		}
		else{
			rexp3();
		}
	}
	
	/**
	 * <rexp2Tail> -> * | + |  E
	 */
	private void rexp2Tail() {
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.KLEENE){
			System.out.println("  [CharClass] KLEENE found... not in char class");
			char_class = false;
			lexer.getNextToken();
			if(scope_back) {
				scope_back = false;
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> start
				 * start --(EPSILON)--> new
				 * current = new
				 */
				t2.addTransition(t2.getCurr(), t2.getStart(), NFA.EPSILON);
				NFA.State s1 = t2.addTransition(t2.getStart(), t2.addState(), NFA.EPSILON);
				t2.setCurr(s1);
				//scope in
				NFA t1 = stack.pop();
				t1.concat(t2);
				stack.push(t1);
			}
			else {
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> current.previous
				 * current.previous --(EPSILON)--> new
				 * current = new
				 */
				NFA.State s1 = t2.addTransition(t2.getCurr(), t2.getCurr().getPrev(), NFA.EPSILON);
				t2.setCurr(s1);
				s1 = t2.addTransition(t2.getCurr(), t2.addState(), NFA.EPSILON);
				s1.setPrev(t2.getCurr());
				t2.setCurr(s1);
				//put back onto stack
				stack.push(t2);
			}
		}
		else if(type == TokenType.PLUS){
			System.out.println("  [CharClass] PLUS found... not in char class");
			char_class = false;
			lexer.getNextToken();
			if(scope_back) {
				scope_back = false;
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> start
				 * current = current
				 */
				t2.addTransition(t2.getCurr(), t2.getStart(), NFA.EPSILON);
				//scope in
				NFA t1 = stack.pop();
				t1.concat(t2);
				stack.push(t1);
			}
			else {
				NFA t2 = stack.pop();
				
				/* current --(EPSILON)--> current.previous
				 * current = current
				 */
				t2.addTransition(t2.getCurr(), t2.getCurr(), NFA.EPSILON);
				
				//put back onto stack
				stack.push(t2);
			}
		}
		else {
			scope_back = false;
			
			//scope back in
			//NFA t2 = stack.pop();
			//NFA t1 = stack.pop();
			//t1.concat(t2);
			//stack.push(t1);
			
			return;
		}
	}
	
	/**
	 * <rexp3> -> <charClass>  |  E 
	 */
	private void rexp3(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.DOT || type == TokenType.LBRACKET || type == TokenType.DEFINED){
			charClass();
		}
		else
			return;
	}
	
	/**
	 * <charClass> ->  .  |  [ <charClass1>  | <definedClass>
	 */
	private void charClass(){
		TokenType type = lexer.peekNextToken().getType();
		
		//System.out.println("[RDescent][charClass] token type: " + type);
		
		if(type == TokenType.DOT){
			lexer.getNextToken();//consume DOT
			
			NFA t2 = stack.pop();
			NFA.State s = t2.addTransition(t2.getCurr(), t2.addState(), DOT_CHAR[0]);
			s.setPrev(t2.getCurr());
			t2.setCurr(s);
			for(int i = 1; i < DOT_CHAR.length; i++) { 
				s = t2.addTransition(t2.getCurr().getPrev(), t2.getCurr(), DOT_CHAR[i]);
			}
			
			stack.push(t2);
		}
		else if(type == TokenType.LBRACKET){
			lexer.getNextToken();//consume LBRACKET
			charClass1();
		}
		else  {
			Token defined = lexer.getNextToken();
			definedClass(defined, false);
		}
	}
	
	/**
	 * <charClass1> ->  <charSetList> | <excludeSet>
	 */
	private void charClass1(){
		TokenType type = lexer.peekNextToken().getType();
		ArrayList<Character> range;
		if(type == TokenType.CARET){
			range = excludeSet(new ArrayList<Character>());
		}
		else{
			range = charSetList(new ArrayList<Character>());
		}
		
		//add range to nfa
		NFA t2 = stack.pop();
		
		System.out.println("    [CharSet] adding \'" + range.get(0) + "\' to range...");
		
		//current --(range[0])--> new
		//new.prev = current
		///current = new
		NFA.State current = t2.addTransition(t2.getCurr(), t2.addState(), range.get(0));
		current.setPrev(t2.getCurr());
		t2.setCurr(current);
		for(int i = 1; i < range.size(); i++) {
			System.out.println("    [CharSet] adding \'" + range.get(i) + "\' to range...");
			t2.addTransition(t2.getCurr().getPrev(), t2.getCurr(), range.get(i));
		}
		
		stack.push(t2);
	}
	
	/**
	 * <charSetList> ->  <charSet> <charSetList> |  E 
	 */
	private ArrayList<Character> charSetList(ArrayList<Character> range){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LITERAL || type == TokenType.DOT){
			//make sure the literal is a CLS_CHAR
			boolean valid = check_valid(lexer.peekNextToken(), CLS_CHAR);
			if(!valid) {
				return range;
			}
			range = charSet(range);
			return charSetList(range);
		}
		else
			return range;
	}
	
	/**
	 * <charSet> -> CLS_CHAR <charSetTail> 
	 */
	private ArrayList<Character> charSet(ArrayList<Character> range){
		Token start = lexer.getNextToken();//consume LITERAL
		return charSetTail(start, range);
	}
	
	/**
	 * <charSetTail> -> - CLS_CHAR | E
	 * @param start starting character for the range
	 */
	private ArrayList<Character> charSetTail(Token start, ArrayList<Character> range){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.DASH){
			lexer.getNextToken();//consume DASH
			Token end = lexer.getNextToken();
			//make sure end is a CLS_CHAR
			boolean valid = check_valid(end, CLS_CHAR);
			if(!valid) {
				//TODO error handling
				return range;
			}
			//make set from range
			int start_index = ((int)start.getValue().charAt(0)) - 32;
			int end_index = ((int)end.getValue().charAt(0)) - 32;
			int current_index = start_index;
			while(current_index <= end_index) {
				range.add(((char)(current_index + 32)));
				current_index++;
			}
			return range;
		}
		else {
			range.add(start.getValue().charAt(0));
			return range;
		}
	}
	
	/**
	 * <excludeSet> -> ^ <charSet>] IN <excludeSetTail>
	 */
	private ArrayList<Character> excludeSet(ArrayList<Character> range){
		lexer.getNextToken();//consume CARET
		ArrayList<Character> exclude = charSet(new ArrayList<Character>());
		lexer.getNextToken();//consume RBRACKET
		lexer.getNextToken();//consume IN
		ArrayList<Character> in = excludeSetTail();
		
		for(int i = 0; i < in.size(); i++) {
			if(!exclude.contains(in.get(i))) {
				range.add(in.get(i));
			}
		}
		
		return range;
	} 
	
	/**
	 * <excludeSetTail> -> [<charSet>]  | <definedClass>
	 */
	private ArrayList<Character> excludeSetTail(){
		TokenType type = lexer.peekNextToken().getType();
		if(type == TokenType.LBRACKET){
			lexer.getNextToken();//consume LBRACKET
			ArrayList<Character> range = charSet(new ArrayList<Character>());
			lexer.getNextToken();//consume RBRACKET
			return range;
		}
		else{
			Token token = lexer.getNextToken();
			ArrayList<Character> range = definedClass(token, true);
			return range;
		}
	}
	
	/**
	 * 
	 * @param token
	 * @param exclude
	 * @return
	 */
	private ArrayList<Character> definedClass(Token token, boolean exclude){
		
		NFA_Identifier phony = new NFA_Identifier(token.getValue(), null, false);
		int index = this.defined.indexOf(phony);
		//make sure it exists
		if(index == -1) {
			//TODO error handling
		}
		NFA_Identifier defined_nfa = this.defined.get(index);
		
		if(exclude) {
			ArrayList<Character> set = new ArrayList<Character>();
			ArrayList<NFA.State.Transition> t = new ArrayList<NFA.State.Transition>();
			NFA.State s1 = defined_nfa.getNFA().getCurr().getPrev();
			t = s1.getTransitions();
			for(int i = 0; i < t.size(); i++) {
				set.add(t.get(i).getLetter());
			}
			return set;
		}
		else {
			//System.out.println("CONCATING CHAR CLASS...");
			NFA top = stack.pop();
			top.concat(defined_nfa.getNFA());
			stack.push(top);
			return null;
		}
	}
	
	/**
	 * check if the given token is contained in the given set
	 * @param token symbol to check validity of
	 * @param set set to check validity with
	 * @return true: token if valid, false: token is invalid
	 */
	private boolean check_valid(Token token, String[] set) {
		for(int i = 0; i < set.length; i++) {
			if(set[i].equals(token.getValue())) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * RE_CHAR set
	 */
	private static final String[] RE_CHAR = {
			"\\ ", "!", "\\\"", "#", "$", "%", "&", "\\\'", "\\(", "\\)", "\\*", "\\+", ",", "-", "\\.", "/",
			"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "\\?", 
			"@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", 
			"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "\\[", "\\\\", "\\]", "^", "_", 
			"`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", 
			"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "\\|", "}", "~"		
	};
	
	/**
	 * CLS_CHAR set
	 */
	private static final String[] CLS_CHAR = {
			" ", "!", "\"", "#", "$", "%", "&", "\'", "(", ")", "*", "+", ",", "\\-", ".", "/",
			"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", 
			"@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", 
			"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "\\[", "\\\\", "\\]", "\\^", "_", 
			"`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", 
			"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~"		
	};
	
	/**
	 * DOT_CHAR set
	 */
	public static final char[] DOT_CHAR = {
			'\\', '*', '+', '?', '|', '[', ']', '(', ')', '.', '\'', '\"'
	};
}

